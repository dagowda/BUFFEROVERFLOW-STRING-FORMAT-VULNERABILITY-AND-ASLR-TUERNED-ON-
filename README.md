# BUFFEROVERFLOW-STRING-FORMAT-VULNERABILITY-WITH-ASLR-TUERNED-ON
Step 1:
The first step would be to analyze the binary code, understand how the program works, and how it’s being executed is crucial, especially when the program is complex. The pre-built tool to use for this is Ghidra in Linux.

![image](https://user-images.githubusercontent.com/114467712/224287481-6d83300b-a473-4247-a739-d042280801d9.png)

There is nothing much happening in the main function as it's only calling a function, which is the loop function.

![image](https://user-images.githubusercontent.com/114467712/224287534-301931f5-909f-4f73-b019-bd655042d8cb.png)

This function might seem overwhelming, but it's only asking us to choose certain options, like an online food ordering system. Each option we choose, a different function relating to that option is called. As we can see from the screenshot, there are four options where we have to input a number which takes us to that particular function.
• Option 1: order function.
• Option 2: status function.
• Option 3: register driver function.
• Option 4: There is no function being called here, it exits the main function and ends the loop (exit(0)).
The vulnerability is in one of these functions.

![image](https://user-images.githubusercontent.com/114467712/224287559-8b8b834a-37b0-4c07-aa0c-799c6cb5495b.png)

Let's strike out the register driver function as it takes an input and then returns to the loop. There is no buffer or anything that we can exploit.
![image](https://user-images.githubusercontent.com/114467712/224287581-fd221fbe-610d-4409-97bc-5e84dfff8468.png)


Next is the order function, 132 bytes are being set up and are being put in a 72-byte-long length buffer that is defined, which shows the sign of vulnerability. We also see something else being called in the same function. Another function which takes the argument “local 10”, where a hexadecimal value is being stored in that variable.
Now we found our overflow function, but we have another problem, the stack smash detector. This is to see if we overflow the buffer. The variable is always placed after the buffer if anyone tries to overflow (in this case 72). If it occurs, then the program exits. This is good up to an extent, until the attacker places the same value at that address and overflows the buffer.

![image](https://user-images.githubusercontent.com/114467712/224287603-11427fe7-37d4-4c19-9f87-b160a3a85c86.png)

The value is the same as the one defined in the order function, which is being compared in the “if statement”.

![image](https://user-images.githubusercontent.com/114467712/224287630-9867485e-090f-436f-8c7d-bac282d2b18e.png)

When I attempted to overflow the buffer and trigger a seg-fault, it didn't work because the program exited. This happened because the value after the 72nd byte was not the same as the hex value defined in "local 10". Now that we have a clearer picture of what to do, we can proceed with our next steps:

The buffer has a size of 72 bytes.
The stack smash is 8 bytes.
RBP has a size of 8 bytes.

![image](https://user-images.githubusercontent.com/114467712/224287663-a81b124a-ebd1-4c07-9086-13bc3707bdef.png)

Finally, we have the return pointer.

![image](https://user-images.githubusercontent.com/114467712/224287689-c40ed929-eb16-4a54-ad54-b7d7087925d2.png)

I sent a payload consisting of 72 'A's, followed by the value of "local 10" (8 bytes), 8 bytes to overwrite RBP ('B'), and another 8 bytes to overwrite RIP ('B'). Now we know that we have control of the return pointer.
Step 2:

Next, we need to construct our payload. There are multiple ways to exploit the program, and I chose the ret2libc method. Other methods include the execve method and inputting shellcode and pointing to the shellcode using ROPs to make the stack executable. This method is used when you need the shellcode to execute some complex operation.

The ret2libc method is simple. We push "bin/sh" into a register (rdi register) and then call system to get a shell. We need the address values of "bin/sh", "pop rdi", and system.

![image](https://user-images.githubusercontent.com/114467712/224287720-6fdef496-934c-4ead-8dd9-e2cfbab196fe.png)

Both these values are in the libc library or the table. We can use the commands "print system" to get the address of system and "search '/bin/sh'" to get the address of the "/bin/sh" string in the libc table.

![image](https://user-images.githubusercontent.com/114467712/224287744-2e1732e7-9d09-43fd-9815-3257fadbd66b.png)

We need to run the command "ROP --grep 'pop rdi'". If we run this command before running the program, it only gives us the offset of the address, which in this case is (0x000000000000146b). The offset cannot be used to point to the ROP gadget. If we get the offset, then we need to know the base of the table.

With ASLR disabled, the payload consists of 72 bytes of nops, the smash value, 8 bytes to overwrite RDI, a pointer to pop rdi, a pointer to the "/bin/sh" string in the libc table, which is then stored in the register RDI, and finally, the system is called. We can see all the addresses in the stack. If we continue, we should get a shell.

![image](https://user-images.githubusercontent.com/114467712/224287779-1d258d2e-ef49-45ac-9708-abc0d4214fab.png)

![image](https://user-images.githubusercontent.com/114467712/224287800-811581ec-8ebe-4605-a718-3071e5ad038e.png)

Step 3:

This was just half the problem. Now we need to find a way to beat this with ASLR enabled. No big deal. We just have to find the addresses of all three values, or any address that is in the particular table of the address we are looking for (in our case, pop rdi, system, /bin/sh) on the stack. It's important to know that we can't use any address that is present on the stack and calculate the offset from that address. The address needs to match the table it's present in.

![image](https://user-images.githubusercontent.com/114467712/224287829-b1fd9ac9-f316-434c-9d1a-d33b7a53ee41.png)

This is where the status function comes into play, which is vulnerable to string format and leaks the addresses that are on the stack. The printf function that directly prints local_48 is vulnerable. It's bad coding practice, but lucky for us, we get to exploit it.

![image](https://user-images.githubusercontent.com/114467712/224287853-539db520-409e-44bf-b64e-621b9fab3abb.png)

As we can see, the address is being leaked.

Step 4:

This was a hassle for me, actually. The addresses I had to leak were the ones marked in blue in the upper screenshot (trial and error).

![image](https://user-images.githubusercontent.com/114467712/224287873-056d0345-68af-4cf2-b4b0-bfb63378d05a.png)

Libc_start_main: This address is leaked when "%23$p" is entered (for system and /bin/sh string). This is because they are in the same table, the addresses are relative and the distance will be the same even if the address changes on every run.
Lib_csu_init: This address is leaked once %11$p is entered (for pop rdi).

Steps:
• Send the io.sendline(‘2’) to trigger the string format vulnerability in the status function.
• Receive the address value and store it in a variable.
• Repeat the previous step to receive the other two addresses.
• Strip all the values using the command strip().decode("utf-8").
• This gives you the hex-string, but there is an extra statement that needs to be removed before getting the address.
• Use the command myStr[13:] to print only the hex string after the 13th character of the string.
• Calculate the offset from the leaked address to all three addresses and retrieve their values.
• These steps need to be performed with ASLR disabled.
• Use the obtained addresses in the payload and execute it to get a shell.

![image](https://user-images.githubusercontent.com/114467712/224287904-d924629f-601c-4577-89e8-e4d80e9baa82.png)

The obtained addresses are printed in every run as shown in the screenshot. We successfully get a shell!

POC
![image](https://user-images.githubusercontent.com/114467712/224287940-500dfdd9-b700-4b9a-b530-dd929b544fcc.png)

![image](https://user-images.githubusercontent.com/114467712/224287960-efb9523a-c0b1-4c5e-9e39-ae831cb4c950.png)
